vec4 CalcLight(BaseLight base, vec3 direction, vec3 normal, vec3 worldPos)
{
	float diffuseFactor = dot(normal, -direction);

	vec4 diffuseColor = vec4(0,0,0,0);
	vec4 specularColor = vec4(0,0,0,0);

	if (diffuseFactor > 0) {
		diffuseColor = vec4(base.color, 1.0) * base.intensity * diffuseFactor;

		vec3 eyeDir = normalize(eyePos - worldPos);
		
		// Phong Lighting Model
		// vec3 reflectionDir = normalize(reflect(direction, normal));
		// float specularFactor = dot(eyeDir, reflectionDir);

		// Almost Phong, but cheaper! ;)
		vec3 halfDir = normalize(eyeDir - direction);
		float specularFactor = dot(halfDir, normal);

		specularFactor = pow(specularFactor, specularPower);

		if (specularFactor > 0) {
			specularColor = vec4(base.color, 1.0) * specularIntensity * specularFactor;
		}
	}

	return diffuseColor + specularColor;
}

vec4 CalcPointLight(PointLight pointLight, vec3 normal, vec3 worldPos)
{
	vec3 lightDir = worldPos - pointLight.position;
	float distance2Point = length(lightDir);

	if (distance2Point > pointLight.range) {
	    return vec4(0, 0, 0, 0);
	}

	lightDir = normalize(lightDir);

	vec4 color =  CalcLight(pointLight.base, lightDir, normal, worldPos);

	float attenuation = pointLight.attenuation.constant +
						pointLight.attenuation.linear * distance2Point +
						pointLight.attenuation.exponent * distance2Point * distance2Point +
						0.0001f; // Make calc division by 0 safe.

	return color / attenuation;
}

vec4 CalcDirectionalLight(DirectionalLight directionalLight, vec3 normal, vec3 worldPos)
{
	return CalcLight(directionalLight.base, -directionalLight.direction, normal, worldPos);
}

vec4 CalcSpotLight(SpotLight spotLight, vec3 normal, vec3 worldPos)
{
	vec3 dir = normalize(worldPos - spotLight.pointLight.position);
	float factor = dot(dir, spotLight.direction);

	vec4 color = vec4(0, 0, 0, 0);

	if (factor > spotLight.cutoff) {
//																Fuzzy Edges!
		color = CalcPointLight(spotLight.pointLight, normal, worldPos) * (1.0 - (1.0 - factor) / (1.0 - spotLight.cutoff));
	}

	return color;
}

float SampleShadowMap(sampler2D shadowMap, vec2 coords, float diff)
{
    return step(diff, texture(shadowMap, coords.xy).r);
}

float CalcShadowEffect(sampler2D shadowMap, vec4 initCoords)
{
    vec3 coord = (initCoords.xyz / initCoords.w) * vec3(0.5) + vec3(0.5);

    return SampleShadowMap(shadowMap, coord.xy, coord.z);
}